<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Rubik's Cube Solver</title>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a1a1a;
            color: #e0e0e0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
        }

        .main-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            max-width: 900px;
            width: 100%;
            background-color: #2c2c2c;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            text-align: center;
        }

        h1 {
            color: #ffffff;
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
        }

        p {
            font-size: 1rem;
            max-width: 600px;
            color: #b0b0b0;
            margin-bottom: 20px;
        }

        .cube-and-controls {
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
            justify-content: center;
            align-items: flex-start;
            gap: 40px;
            width: 100%;
        }
        
        .setup-section, .solve-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        .solve-section {
            display: none; /* Initially hidden */
        }
        
        .cube-container-2d {
            display: grid;
            grid-template-areas:
                ". top ."
                "left front right"
                ". bottom ."
                ". back .";
            gap: 2px;
            background-color: #333;
            padding: 5px;
            border-radius: 8px;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.5);
            transform: scale(0.8);
        }

        .face {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 2px;
            padding: 5px;
            background-color: #333;
            border: 2px solid #222;
        }

        .face.top    { grid-area: top; }
        .face.front  { grid-area: front; }
        .face.left   { grid-area: left; }
        .face.right  { grid-area: right; }
        .face.back   { grid-area: back; }
        .face.bottom { grid-area: bottom; }

        .sticker {
            width: 40px;
            height: 40px;
            border: 1px solid #1a1a1a;
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.2);
            transition: background-color 0.2s ease;
            cursor: pointer;
        }
        
        .sticker.center {
            cursor: default;
        }
        
        .color-palette {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
            padding: 10px;
            background-color: #333;
            border-radius: 8px;
        }

        .color-box {
            width: 30px;
            height: 30px;
            border-radius: 4px;
            border: 2px solid #555;
            cursor: pointer;
            transition: transform 0.2s;
        }
        
        .color-box.selected {
            border-color: #fff;
            box-shadow: 0 0 8px #fff;
            transform: scale(1.1);
        }

        .controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            width: 250px;
        }
        
        .controls-row {
            display: flex;
            gap: 10px;
            width: 100%;
        }

        .controls .btn {
            background-color: #444;
            color: #fff;
            border: none;
            padding: 12px 24px;
            font-size: 1rem;
            font-weight: 600;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
            text-transform: uppercase;
            letter-spacing: 1px;
            outline: none;
            width: 100%;
        }
        
        .controls-row .btn {
            width: 50%;
        }

        .controls .btn:hover {
            background-color: #555;
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.3);
        }

        .controls .btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .controls .btn:disabled {
            background-color: #333;
            color: #888;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .controls .btn.start-solve, .controls .btn.scramble-cube {
            background-color: #007BFF;
        }
        
        .controls .btn.start-solve:hover, .controls .btn.scramble-cube:hover {
            background-color: #0069d9;
        }

        .controls .btn.next-step {
            background-color: #4CAF50;
        }
        
        .controls .btn.next-step:hover {
            background-color: #45a049;
        }
        
        .controls .btn.secondary {
            background-color: #555;
        }
        
        .controls .btn.secondary:hover {
            background-color: #666;
        }

        .instruction-box {
            background-color: #333;
            color: #e0e0e0;
            border-radius: 8px;
            padding: 15px;
            text-align: left;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.5);
            width: 100%;
        }
        
        .instruction-box h3 {
            margin-top: 0;
            color: #ffffff;
            font-size: 1.2rem;
            border-bottom: 1px solid #555;
            padding-bottom: 10px;
            margin-bottom: 10px;
        }

        .instruction-box p {
            margin: 0 0 10px 0;
            text-align: left;
        }

        .instruction-box code {
            background-color: #444;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 0.9rem;
            color: #FFD700;
        }

        .message-box {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #333;
            color: #fff;
            padding: 15px 25px;
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.5s ease, visibility 0.5s ease;
        }

        .message-box.show {
            opacity: 1;
            visibility: visible;
        }
        
        @media (max-width: 768px) {
            .cube-and-controls {
                flex-direction: column;
                align-items: center;
            }
            .cube-container-2d {
                transform: scale(0.9);
            }
            .controls {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="main-container">
        <h1>Interactive Rubik's Cube Solver</h1>
        <p>Enter the colors of your scrambled cube or click 'Scramble Cube' to get a new one. Then, follow the step-by-step instructions to solve it!</p>

        <div class="cube-and-controls">
            <!-- Manual Input Section -->
            <div class="setup-section" id="setupSection">
                <div id="cubeContainer2D" class="cube-container-2d">
                    <!-- Faces will be dynamically added here -->
                </div>
                <div class="color-palette" id="colorPalette">
                    <!-- Colors will be dynamically added here -->
                </div>
                <div class="controls">
                    <button class="btn start-solve" onclick="startSolving()">Start Solving</button>
                    <button class="btn scramble-cube" onclick="scrambleCubeAndSolve()">Scramble Cube</button>
                    <button class="btn secondary" onclick="resetCube()">Reset</button>
                </div>
            </div>

            <!-- Solving Section -->
            <div class="solve-section" id="solveSection">
                <div id="solveCubeContainer2D" class="cube-container-2d">
                    <!-- Faces will be dynamically added here -->
                </div>
                <div class="controls">
                    <div class="instruction-box" id="instructionBox">
                        <h3>Instructions</h3>
                        <p id="simpleInstruction">Click "Next Step" to begin solving the cube.</p>
                        <p id="detailedInstruction"></p>
                        <p id="currentMove"></p>
                    </div>
                    <div class="controls-row">
                        <button class="btn" id="prevStepBtn" onclick="previousStep()">Previous Step</button>
                        <button class="btn next-step" id="nextStepBtn" onclick="nextStep()">Next Step</button>
                    </div>
                    <button class="btn secondary" onclick="showHome()">Home</button>
                </div>
            </div>
        </div>
    </div>

    <div id="messageBox" class="message-box"></div>

    <script>
        // Use a more accessible color palette
        const COLORS = {
            'white': '#ffffff',
            'yellow': '#ffd700',
            'red': '#ff0000',
            'orange': '#ff8c00',
            'blue': '#0000ff',
            'green': '#008000',
        };
        const COLOR_NAMES = ['white', 'yellow', 'red', 'orange', 'blue', 'green'];
        const FACES = ['front', 'back', 'top', 'bottom', 'left', 'right'];
        const ALL_MOVES = ['U', 'U_prime', 'D', 'D_prime', 'R', 'R_prime', 'L', 'L_prime', 'F', 'F_prime', 'B', 'B_prime'];
        const SCRAMBLE_LENGTH = 25;

        let cubeState = {};
        let solvedCubeState = {};
        let selectedColor = 'white';
        let setupSection, solveSection;
        let instructionBox, simpleInstruction, detailedInstruction, currentMoveDisplay;
        let solvingSteps = [];
        let currentStepIndex = -1;

        // --- UI Initialization ---
        function initializeUI() {
            setupSection = document.getElementById('setupSection');
            solveSection = document.getElementById('solveSection');
            instructionBox = document.getElementById('instructionBox');
            simpleInstruction = document.getElementById('simpleInstruction');
            detailedInstruction = document.getElementById('detailedInstruction');
            currentMoveDisplay = document.getElementById('currentMove');
            
            createCubeGrid('cubeContainer2D', true); // Create interactive cube for input
            createCubeGrid('solveCubeContainer2D', false); // Create passive cube for solving display
            createColorPalette();
            resetCubeState();
            updateCubeDisplay();
            updateNavigationButtons();
        }

        // Creates a 2D cube grid and attaches event listeners if interactive
        function createCubeGrid(containerId, isInteractive) {
            const container = document.getElementById(containerId);
            container.innerHTML = '';
            
            FACES.forEach(faceName => {
                const face = document.createElement('div');
                face.className = `face ${faceName}`;
                face.dataset.face = faceName;
                for (let i = 0; i < 9; i++) {
                    const sticker = document.createElement('div');
                    sticker.className = `sticker ${i === 4 ? 'center' : ''}`;
                    sticker.dataset.index = i;
                    if (isInteractive && i !== 4) {
                        sticker.addEventListener('click', handleStickerClick);
                    }
                    face.appendChild(sticker);
                }
                container.appendChild(face);
            });
        }
        
        // Creates the color palette for manual input
        function createColorPalette() {
            const palette = document.getElementById('colorPalette');
            palette.innerHTML = '';
            COLOR_NAMES.forEach(color => {
                const colorBox = document.createElement('div');
                colorBox.className = 'color-box';
                colorBox.style.backgroundColor = COLORS[color];
                colorBox.dataset.color = color;
                colorBox.addEventListener('click', handleColorPaletteClick);
                palette.appendChild(colorBox);
            });
            // Select the initial color
            document.querySelector(`[data-color="${selectedColor}"]`).classList.add('selected');
        }

        // Event handler for selecting a color
        function handleColorPaletteClick(event) {
            const oldSelected = document.querySelector('.color-box.selected');
            if (oldSelected) oldSelected.classList.remove('selected');
            selectedColor = event.target.dataset.color;
            event.target.classList.add('selected');
        }

        // Event handler for clicking a sticker to change its color
        function handleStickerClick(event) {
            const sticker = event.target;
            const face = sticker.parentElement.dataset.face;
            const index = sticker.dataset.index;
            cubeState[face][index] = selectedColor;
            updateCubeDisplay();
        }

        // Resets the cube to a solved state for fresh input
        function resetCubeState() {
            solvedCubeState = {
                'front': ['green', 'green', 'green', 'green', 'green', 'green', 'green', 'green', 'green'],
                'back': ['blue', 'blue', 'blue', 'blue', 'blue', 'blue', 'blue', 'blue', 'blue'],
                'top': ['white', 'white', 'white', 'white', 'white', 'white', 'white', 'white', 'white'],
                'bottom': ['yellow', 'yellow', 'yellow', 'yellow', 'yellow', 'yellow', 'yellow', 'yellow', 'yellow'],
                'left': ['orange', 'orange', 'orange', 'orange', 'orange', 'orange', 'orange', 'orange', 'orange'],
                'right': ['red', 'red', 'red', 'red', 'red', 'red', 'red', 'red', 'red']
            };
            cubeState = JSON.parse(JSON.stringify(solvedCubeState));
        }

        // Updates the visual display of the cube based on the cubeState array
        function updateCubeDisplay() {
            FACES.forEach(faceName => {
                const setupFaceElement = document.querySelector(`#cubeContainer2D .face.${faceName}`);
                const solveFaceElement = document.querySelector(`#solveCubeContainer2D .face.${faceName}`);
                if (setupFaceElement) {
                  const stickers = setupFaceElement.querySelectorAll('.sticker');
                  cubeState[faceName].forEach((color, index) => {
                      stickers[index].style.backgroundColor = COLORS[color];
                  });
                }
                if (solveFaceElement) {
                  const solveStickers = solveFaceElement.querySelectorAll('.sticker');
                  cubeState[faceName].forEach((color, index) => {
                      solveStickers[index].style.backgroundColor = COLORS[color];
                  });
                }
            });
        }
        
        // --- Core Application Flow ---
        function startSolving() {
            // Check if the cube is already solved
            if (isSolved()) {
                showMessage("The cube is already solved!", 3000);
                return;
            }

            // 1. Validate the cube state
            if (!validateCubeState()) {
                showMessage("Invalid cube state. Please ensure you have 9 stickers of each color.", 5000);
                return;
            }

            // 2. Generate the full solution
            solvingSteps = generateSolution();
            currentStepIndex = -1; // Start before the first step
            
            // 3. Switch to solve view
            setupSection.style.display = 'none';
            solveSection.style.display = 'flex';
            
            // 4. Start the solving process
            updateUIForStep();
        }
        
        function nextStep() {
            if (currentStepIndex < solvingSteps.length - 1) {
                currentStepIndex++;
                const step = solvingSteps[currentStepIndex];
                if (step.move) {
                    applyMove(step.move);
                }
                updateUIForStep();

                if (isSolved()) {
                    showMessage("Congratulations! The cube is solved!", 5000);
                    document.getElementById('nextStepBtn').disabled = true;
                }
            } else {
                showMessage("You have reached the end of this guide.", 2000);
            }
        }
        
        function previousStep() {
            if (currentStepIndex > -1) {
                const step = solvingSteps[currentStepIndex];
                if (step.move) {
                    const inverseMove = getInverseMove(step.move);
                    applyMove(inverseMove);
                }
                currentStepIndex--;
                updateUIForStep();

                // Re-enable the next step button if we move back from a solved state
                document.getElementById('nextStepBtn').disabled = false;
            } else {
                showMessage("You are at the beginning of the solution.", 2000);
            }
        }
        
        function getInverseMove(move) {
            switch(move) {
                case 'U': return 'U_prime';
                case 'U_prime': return 'U';
                case 'D': return 'D_prime';
                case 'D_prime': return 'D';
                case 'R': return 'R_prime';
                case 'R_prime': return 'R';
                case 'L': return 'L_prime';
                case 'L_prime': return 'L';
                case 'F': return 'F_prime';
                case 'F_prime': return 'F';
                case 'B': return 'B_prime';
                case 'B_prime': return 'B';
                default: return null;
            }
        }

        function updateUIForStep() {
            const prevBtn = document.getElementById('prevStepBtn');
            const nextBtn = document.getElementById('nextStepBtn');

            // Disable/Enable buttons based on current step
            prevBtn.disabled = currentStepIndex <= -1;
            nextBtn.disabled = currentStepIndex >= solvingSteps.length - 1 || isSolved();

            if (currentStepIndex === -1) {
                // Initial state before solving starts
                simpleInstruction.textContent = "Click 'Next Step' to begin solving the cube.";
                detailedInstruction.textContent = "This will apply the first move of the solution.";
                currentMoveDisplay.innerHTML = "";
            } else {
                const step = solvingSteps[currentStepIndex];
                
                updateCubeDisplay();
                
                // Update instructions
                simpleInstruction.textContent = step.simpleText;
                detailedInstruction.textContent = step.detailedText;
                currentMoveDisplay.innerHTML = step.move ? `Move: <code>${step.move}</code>` : '';
            }

            if (isSolved()) {
                showMessage("The cube is now solved!", 5000);
                nextBtn.disabled = true;
            }
        }
        
        function showHome() {
            // Return to the setup screen
            setupSection.style.display = 'flex';
            solveSection.style.display = 'none';
            updateNavigationButtons();
            // Reset the cube to the solved state to prevent confusion
            resetCubeState();
            updateCubeDisplay();
        }

        function resetCube() {
            resetCubeState();
            updateCubeDisplay();
            showHome();
            showMessage("Cube state has been reset.", 2000);
        }
        
        function scrambleCubeAndSolve() {
            resetCubeState(); // Start from a solved state
            
            // Generate a random scramble of SCRAMBLE_LENGTH moves
            const tempCubeState = JSON.parse(JSON.stringify(cubeState));
            const scrambleMoves = [];
            for (let i = 0; i < SCRAMBLE_LENGTH; i++) {
                const randomMove = ALL_MOVES[Math.floor(Math.random() * ALL_MOVES.length)];
                scrambleMoves.push(randomMove);
                applyMove(randomMove);
            }
            
            updateCubeDisplay();
            startSolving();
        }
        
        function updateNavigationButtons() {
            const prevBtn = document.getElementById('prevStepBtn');
            const nextBtn = document.getElementById('nextStepBtn');
            if (prevBtn) prevBtn.disabled = true;
            if (nextBtn) nextBtn.disabled = false;
        }

        // --- Core Solving Algorithm Logic ---
        function generateSolution() {
            let solutionSteps = [];
            let tempCubeState = JSON.parse(JSON.stringify(cubeState));

            // Chain the solver functions, passing the temporary state through each one
            tempCubeState = solveWhiteCross(solutionSteps, tempCubeState);
            tempCubeState = solveWhiteCorners(solutionSteps, tempCubeState);
            tempCubeState = solveMiddleLayer(solutionSteps, tempCubeState);
            tempCubeState = solveYellowCross(solutionSteps, tempCubeState);
            tempCubeState = positionLastLayerEdges(solutionSteps, tempCubeState);
            tempCubeState = positionLastLayerCorners(solutionSteps, tempCubeState);
            tempCubeState = orientLastLayerCorners(solutionSteps, tempCubeState);

            if (solutionSteps.length === 0) {
                solutionSteps.push({ simpleText: "The cube is already solved!", detailedText: "", move: null });
            }

            return solutionSteps;
        }

        // Applies a sequence of moves to a temporary state and records the steps
        function applyMovesToTempState(sequence, steps, simpleText, detailedText, tempState) {
            const moves = sequence.split(' ').filter(m => m !== '');
            let newTempState = tempState;
            for (const move of moves) {
                steps.push({ simpleText, detailedText, move });
                newTempState = getNextState(newTempState, move);
            }
            return newTempState;
        }

        // Helper function to find an edge piece in a given cube state
        function findEdge(cube, color1, color2) {
            const edgePositions = [
                { name: 'UB', faces: ['top', 'back'], indices: [1, 1] }, { name: 'UL', faces: ['top', 'left'], indices: [3, 1] },
                { name: 'UR', faces: ['top', 'right'], indices: [5, 1] }, { name: 'UF', faces: ['top', 'front'], indices: [7, 1] },
                { name: 'FL', faces: ['front', 'left'], indices: [3, 5] }, { name: 'FR', faces: ['front', 'right'], indices: [5, 3] },
                { name: 'BL', faces: ['back', 'left'], indices: [5, 3] }, { name: 'BR', faces: ['back', 'right'], indices: [3, 5] },
                { name: 'DF', faces: ['bottom', 'front'], indices: [1, 7] }, { name: 'DL', faces: ['bottom', 'left'], indices: [3, 7] },
                { name: 'DR', faces: ['bottom', 'right'], indices: [5, 7] }, { name: 'DB', faces: ['bottom', 'back'], indices: [7, 7] },
            ];
            for (const pos of edgePositions) {
                const c1 = cube[pos.faces[0]][pos.indices[0]];
                const c2 = cube[pos.faces[1]][pos.indices[1]];
                if ((c1 === color1 && c2 === color2) || (c1 === color2 && c2 === color1)) {
                    return { pos: pos, colorOnFace1: c1, colorOnFace2: c2 };
                }
            }
            return null;
        }

        // --- Stage 1: White Cross ---
        function solveWhiteCross(steps, initialCubeState) {
            let tempState = JSON.parse(JSON.stringify(initialCubeState));
            const stageTitle = "Step 1: White Cross";

            const edgesToSolve = [
                { colors: ['white', 'green'], targetFace: 'front' }, { colors: ['white', 'red'], targetFace: 'right' },
                { colors: ['white', 'blue'], targetFace: 'back' }, { colors: ['white', 'orange'], targetFace: 'left' }
            ];
            const faceToMove = { front: 'F', right: 'R', back: 'B', left: 'L' };
            const faceOrder = ['front', 'right', 'back', 'left'];

            for (const edge of edgesToSolve) {
                for (let i = 0; i < 10; i++) {
                    const edgeLocation = findEdge(tempState, ...edge.colors);
                    const { pos, colorOnFace1 } = edgeLocation;

                    if (pos.faces.includes('top') && pos.faces.includes(edge.targetFace) && tempState.top[pos.indices[0]] === 'white') break;

                    if (pos.faces.includes('top')) {
                        const move = faceToMove[pos.faces[1]];
                        tempState = applyMovesToTempState(move, steps, `${stageTitle}: Move ${edge.colors.join('-')} out of top layer`, `Moving from ${pos.name} to the bottom layer.`, tempState);
                        continue;
                    }
                    if (['FL', 'FR', 'BL', 'BR'].includes(pos.name)) {
                        const move = pos.name.includes('R') ? 'R' : 'L';
                        tempState = applyMovesToTempState(getInverseMove(move), steps, `${stageTitle}: Move ${edge.colors.join('-')} from middle layer`, `Moving from ${pos.name} to the bottom layer.`, tempState);
                        continue;
                    }
                    if (pos.faces.includes('bottom')) {
                        const whiteOnBottom = (pos.faces[0] === 'bottom' && colorOnFace1 === 'white') || (pos.faces[1] === 'bottom' && colorOnFace1 !== 'white');
                        if (whiteOnBottom) {
                            const sideColor = colorOnFace1 === 'white' ? edgeLocation.colorOnFace2 : colorOnFace1;
                            const targetCenterFace = edgesToSolve.find(e => e.colors.includes(sideColor)).targetFace;
                            const currentSideFace = pos.faces[1];
                            const targetIdx = faceOrder.indexOf(targetCenterFace);
                            const currentIdx = faceOrder.indexOf(currentSideFace);
                            let diff = (targetIdx - currentIdx + 4) % 4;
                            let moves = ['', 'D', 'D D', 'D_prime'][diff];
                            if (moves) tempState = applyMovesToTempState(moves, steps, `${stageTitle}: Align ${edge.colors.join('-')} edge`, `Positioning the edge under its destination.`, tempState);
                            const finalMove = `${faceToMove[targetCenterFace]} ${faceToMove[targetCenterFace]}`;
                            tempState = applyMovesToTempState(finalMove, steps, `${stageTitle}: Insert ${edge.colors.join('-')} edge`, `Flipping the edge into the white cross.`, tempState);
                        } else {
                            const targetIdx = faceOrder.indexOf(edge.targetFace);
                            const currentIdx = faceOrder.indexOf(pos.faces[1]);
                            let diff = (targetIdx - currentIdx + 4) % 4;
                            let moves = ['', 'D', 'D D', 'D_prime'][diff];
                            if (moves) tempState = applyMovesToTempState(moves, steps, `${stageTitle}: Position ${edge.colors.join('-')} for insertion`, `Moving the edge to its target face.`, tempState);
                            const face = faceToMove[edge.targetFace];
                            const rightFace = faceToMove[faceOrder[(targetIdx + 1) % 4]];
                            const insertionAlg = `${getInverseMove(face)} ${getInverseMove(rightFace)} ${face}`;
                            tempState = applyMovesToTempState(insertionAlg, steps, `${stageTitle}: Insert ${edge.colors.join('-')} edge`, `Using algorithm ${insertionAlg} to insert the edge.`, tempState);
                        }
                        break;
                    }
                }
            }
            return tempState;
        }

        function findCorner(cube, c1, c2, c3) {
            const cornerPositions = [
                { name: 'UBL', faces: ['top', 'back', 'left'], indices: [0, 2, 0] }, { name: 'UBR', faces: ['top', 'back', 'right'], indices: [2, 0, 2] },
                { name: 'UFL', faces: ['top', 'front', 'left'], indices: [6, 0, 2] }, { name: 'UFR', faces: ['top', 'front', 'right'], indices: [8, 2, 0] },
                { name: 'DBL', faces: ['bottom', 'back', 'left'], indices: [6, 8, 6] }, { name: 'DBR', faces: ['bottom', 'back', 'right'], indices: [8, 6, 8] },
                { name: 'DFL', faces: ['bottom', 'front', 'left'], indices: [0, 6, 8] }, { name: 'DFR', faces: ['bottom', 'front', 'right'], indices: [2, 8, 6] },
            ];
            for (const pos of cornerPositions) {
                const c = [cube[pos.faces[0]][pos.indices[0]], cube[pos.faces[1]][pos.indices[1]], cube[pos.faces[2]][pos.indices[2]]];
                if (c.includes(c1) && c.includes(c2) && c.includes(c3)) return { pos: pos, colors: c };
            }
            return null;
        }

        // --- Stage 2: White Corners ---
        function solveWhiteCorners(steps, initialCubeState) {
            let tempState = JSON.parse(JSON.stringify(initialCubeState));
            const stageTitle = "Step 2: White Corners";

            const cornersToSolve = [
                { colors: ['white', 'green', 'orange'], targetPos: 'UFL' }, { colors: ['white', 'green', 'red'], targetPos: 'UFR' },
                { colors: ['white', 'blue', 'orange'], targetPos: 'UBL' }, { colors: ['white', 'blue', 'red'], targetPos: 'UBR' },
            ];
            const posMap = { DFL: 0, DFR: 1, DBR: 2, DBL: 3 };

            for (const corner of cornersToSolve) {
                for (let i = 0; i < 6; i++) {
                    const cornerLocation = findCorner(tempState, ...corner.colors);
                    const { pos } = cornerLocation;
                    if (pos.name === corner.targetPos && tempState.top[pos.indices[0]] === 'white') break;

                    if (pos.name.startsWith('U')) {
                        const move = pos.name.includes('R') ? 'R' : 'L';
                        const sequence = `${getInverseMove(move)} D ${move}`;
                        tempState = applyMovesToTempState(sequence, steps, `${stageTitle}: Bring ${corner.colors.join('-')} down`, `Moving the corner from the top to the bottom layer.`, tempState);
                        continue;
                    }
                    if (pos.name.startsWith('D')) {
                        const targetSlotName = 'D' + corner.targetPos.substring(1);
                        const currentSlotName = pos.name;
                        const diff = (posMap[targetSlotName] - posMap[currentSlotName] + 4) % 4;
                        let dMoves = ['', 'D', 'D D', 'D_prime'][diff];
                        if (dMoves) tempState = applyMovesToTempState(dMoves, steps, `${stageTitle}: Position ${corner.colors.join('-')} corner`, `Moving the corner under its target slot.`, tempState);

                        const targetFace = corner.targetPos.includes('R') ? 'R' : 'L';
                        const sequence = `${getInverseMove(targetFace)} D_prime ${targetFace} D`;
                        tempState = applyMovesToTempState(sequence, steps, `${stageTitle}: Insert ${corner.colors.join('-')} corner`, `Repeating algorithm to orient and insert the corner.`, tempState);
                    }
                }
            }
            return tempState;
        }

        // --- Stage 3: Middle Layer ---
        function solveMiddleLayer(steps, initialCubeState) {
            let tempState = JSON.parse(JSON.stringify(initialCubeState));
            const stageTitle = "Step 3: Middle Layer";
            const middleEdges = [
                { colors: ['green', 'red'], home: 'FR' }, { colors: ['green', 'orange'], home: 'FL' },
                { colors: ['blue', 'red'], home: 'BR' }, { colors: ['blue', 'orange'], home: 'BL' }
            ];
            const faceOrder = ['front', 'right', 'back', 'left'];

            for (let i = 0; i < 5; i++) {
                const solvedEdges = middleEdges.filter(edge => {
                    const loc = findEdge(tempState, ...edge.colors);
                    return loc && loc.pos.name === edge.home;
                });
                if (solvedEdges.length === 4) break;

                let edgeToInsert = null;
                const bottomEdges = ['DF', 'DL', 'DR', 'DB'];
                const faceMap = { F: 'front', L: 'left', R: 'right', B: 'back' };
                const bottomIndexMap = { DF: 1, DL: 3, DR: 5, DB: 7 };

                for (const posName of bottomEdges) {
                    const sideFaceName = faceMap[posName.charAt(1)];
                    const bottomStickerIndex = bottomIndexMap[posName];
                    const sideStickerIndex = 7;

                    const edgeData = findEdge(tempState, tempState.bottom[bottomStickerIndex], tempState[sideFaceName][sideStickerIndex]);

                    if (edgeData && !edgeData.colorOnFace1.includes('yellow') && !edgeData.colorOnFace2.includes('yellow')) {
                        const middleEdge = middleEdges.find(me => me.colors.includes(edgeData.colorOnFace1) && me.colors.includes(edgeData.colorOnFace2));
                        if(middleEdge && findEdge(tempState, ...middleEdge.colors).pos.name !== middleEdge.home) {
                            edgeToInsert = edgeData;
                            break;
                        }
                    }
                }

                if (edgeToInsert) {
                    const sideColor = edgeToInsert.pos.faces[0] === 'bottom' ? edgeToInsert.colorOnFace2 : edgeToInsert.colorOnFace1;
                    const bottomColor = edgeToInsert.pos.faces[0] === 'bottom' ? edgeToInsert.colorOnFace1 : edgeToInsert.colorOnFace2;
                    const alignToFace = Object.keys(solvedCubeState).find(f => solvedCubeState[f][4] === sideColor);
                    const currentFace = edgeToInsert.pos.faces[1];
                    const targetIdx = faceOrder.indexOf(alignToFace);
                    const currentIdx = faceOrder.indexOf(currentFace);
                    let diff = (targetIdx - currentIdx + 4) % 4;
                    let dMoves = ['', 'D', 'D D', 'D_prime'][diff];
                    if (dMoves) tempState = applyMovesToTempState(dMoves, steps, `${stageTitle}: Align ${sideColor}-${bottomColor} edge`, `Aligning the edge with its center color.`, tempState);

                    const destColor = bottomColor;
                    const rightFace = faceOrder[(faceOrder.indexOf(alignToFace) + 1) % 4];
                    const moves = solvedCubeState[rightFace][4] === destColor ? `D R D' R' D' F' D F` : `D' L' D L D F D' F'`;
                    tempState = applyMovesToTempState(moves, steps, `${stageTitle}: Insert ${sideColor}-${destColor}`, `Using algorithm to place the edge.`, tempState);
                } else {
                    let wrongEdge = middleEdges.map(edge => findEdge(tempState, ...edge.colors)).find(loc => loc.pos.name !== middleEdges.find(me => me.colors.includes(loc.colorOnFace1) && me.colors.includes(loc.colorOnFace2)).home);
                    if (wrongEdge) {
                        const moves = `D R D' R' D' F' D F`; // Just use right-insert to displace
                        tempState = applyMovesToTempState(moves, steps, `${stageTitle}: Displace ${wrongEdge.colorOnFace1}-${wrongEdge.colorOnFace2} edge`, `Moving a wrongly placed edge out of the middle layer.`, tempState);
                    }
                }
            }
            return tempState;
        }

        // --- Stage 4: Yellow Cross ---
        function solveYellowCross(steps, initialCubeState) {
            let tempState = JSON.parse(JSON.stringify(initialCubeState));
            const stageTitle = "Step 4: Yellow Cross";
            const algLine = "F R D R' D' F'";
            const algL = "F D R D' R' F'";

            for (let i = 0; i < 4; i++) {
                const yellowEdges = {
                    front: tempState.bottom[1] === 'yellow', left: tempState.bottom[3] === 'yellow',
                    right: tempState.bottom[5] === 'yellow', back: tempState.bottom[7] === 'yellow',
                };
                const count = Object.values(yellowEdges).filter(Boolean).length;
                if (count === 4) break;

                if (count === 0) {
                    tempState = applyMovesToTempState(algLine, steps, `${stageTitle}: From Dot`, `Applying algorithm to create the initial L-shape.`, tempState);
                } else if (count === 2) {
                    const isLine = (yellowEdges.front && yellowEdges.back) || (yellowEdges.left && yellowEdges.right);
                    if (isLine) {
                        if (yellowEdges.front && yellowEdges.back) tempState = applyMovesToTempState("D", steps, `${stageTitle}: Orient Line`, `Making the line horizontal.`, tempState);
                        tempState = applyMovesToTempState(algLine, steps, `${stageTitle}: From Line`, `Applying algorithm to turn the line into a cross.`, tempState);
                    } else {
                        let dMoves = '';
                        if (yellowEdges.front && yellowEdges.right) dMoves = "D";
                        else if (yellowEdges.front && yellowEdges.left) dMoves = "D D";
                        else if (yellowEdges.back && yellowEdges.right) dMoves = "D_prime";
                        if (dMoves) tempState = applyMovesToTempState(dMoves, steps, `${stageTitle}: Orient L-shape`, `Positioning the L-shape in the back-left.`, tempState);
                        tempState = applyMovesToTempState(algL, steps, `${stageTitle}: From L-shape`, `Applying algorithm to turn the L-shape into a line.`, tempState);
                    }
                }
            }
            return tempState;
        }

        // --- Stage 5: Position Last Layer Edges ---
        function positionLastLayerEdges(steps, initialCubeState) {
            let tempState = JSON.parse(JSON.stringify(initialCubeState));
            const stageTitle = "Step 5: Position Edges";
            const alg = "R D R' D R D D R' D";

            for (let i = 0; i < 4; i++) {
                const solvedCount = ['front', 'right', 'back', 'left'].filter(f => tempState[f][7] === solvedCubeState[f][4]).length;
                if (solvedCount >= 2) break;
                tempState = applyMovesToTempState("D", steps, `${stageTitle}: Align Cross`, `Trying to match as many edges as possible.`, tempState);
            }

            for (let i = 0; i < 3; i++) {
                const solvedEdges = {
                    front: tempState.front[7] === solvedCubeState.front[4], right: tempState.right[7] === solvedCubeState.right[4],
                    back: tempState.back[7] === solvedCubeState.back[4], left: tempState.left[7] === solvedCubeState.left[4],
                };
                if (Object.values(solvedEdges).filter(Boolean).length === 4) break;
                const isAdjacent = (solvedEdges.front && solvedEdges.right) || (solvedEdges.right && solvedEdges.back) || (solvedEdges.back && solvedEdges.left) || (solvedEdges.left && solvedEdges.front);
                if (isAdjacent) {
                    let setupMoves = '';
                    if (solvedEdges.front && solvedEdges.left) setupMoves = "D";
                    else if (solvedEdges.front && solvedEdges.right) setupMoves = "D D";
                    else if (solvedEdges.right && solvedEdges.back) setupMoves = "D_prime";
                    if (setupMoves) tempState = applyMovesToTempState(setupMoves, steps, `${stageTitle}: Orient Adjacent`, `Positioning solved edges to the back and left.`, tempState);
                    tempState = applyMovesToTempState(alg, steps, `${stageTitle}: Permute Adjacent`, `Solving the final two edges.`, tempState);
                } else {
                    if (solvedEdges.left && solvedEdges.right) tempState = applyMovesToTempState("D", steps, `${stageTitle}: Orient Opposite`, `Positioning a solved edge to the back.`, tempState);
                    tempState = applyMovesToTempState(alg, steps, `${stageTitle}: Permute Opposite`, `This will result in two adjacent edges being solved.`, tempState);
                }
            }
            return tempState;
        }

        // --- Stage 6: Position Last Layer Corners ---
        function positionLastLayerCorners(steps, initialCubeState) {
            let tempState = JSON.parse(JSON.stringify(initialCubeState));
            const stageTitle = "Step 6: Position Corners";
            const alg = "D R D' L' D R' D' L";

            for (let i = 0; i < 4; i++) {
                const corners = { DBR: findCornerByPos(tempState, 'DBR'), DBL: findCornerByPos(tempState, 'DBL'), DFR: findCornerByPos(tempState, 'DFR'), DFL: findCornerByPos(tempState, 'DFL') };
                const isCorrectlyPositioned = (cornerName) => {
                    const targetColors = [solvedCubeState[corners[cornerName].pos.faces[0]][corners[cornerName].pos.indices[0]], solvedCubeState[corners[cornerName].pos.faces[1]][corners[cornerName].pos.indices[1]], solvedCubeState[corners[cornerName].pos.faces[2]][corners[cornerName].pos.indices[2]]];
                    return targetColors.every(c => corners[cornerName].colors.includes(c));
                };
                const solvedCorners = Object.keys(corners).filter(isCorrectlyPositioned);
                if (solvedCorners.length === 4) break;
                if (solvedCorners.length === 1) {
                    const solvedCornerName = solvedCorners[0];
                    let setupMoves = '';
                    if (solvedCornerName === 'DFL') setupMoves = 'D';
                    else if (solvedCornerName === 'DFR') setupMoves = 'D D';
                    else if (solvedCornerName === 'DBL') setupMoves = "D_prime";
                    if (setupMoves) tempState = applyMovesToTempState(setupMoves, steps, `${stageTitle}: Orient for Permutation`, `Placing the solved corner in the back-right.`, tempState);
                    tempState = applyMovesToTempState(alg, steps, `${stageTitle}: Permute 3 Corners`, `Cycling the remaining three corners into position.`, tempState);
                } else {
                    tempState = applyMovesToTempState(alg, steps, `${stageTitle}: Permute Corners`, `Applying algorithm to position at least one corner correctly.`, tempState);
                }
            }
            return tempState;
        }

        function findCornerByPos(cube, cornerName) {
            const cornerPositions = [
                { name: 'UBL', faces: ['top', 'back', 'left'], indices: [0, 2, 0] }, { name: 'UBR', faces: ['top', 'back', 'right'], indices: [2, 0, 2] },
                { name: 'UFL', faces: ['top', 'front', 'left'], indices: [6, 0, 2] }, { name: 'UFR', faces: ['top', 'front', 'right'], indices: [8, 2, 0] },
                { name: 'DBL', faces: ['bottom', 'back', 'left'], indices: [6, 8, 6] }, { name: 'DBR', faces: ['bottom', 'back', 'right'], indices: [8, 6, 8] },
                { name: 'DFL', faces: ['bottom', 'front', 'left'], indices: [0, 6, 8] }, { name: 'DFR', faces: ['bottom', 'front', 'right'], indices: [2, 8, 6] },
            ];
            const pos = cornerPositions.find(p => p.name === cornerName);
            if (!pos) return null;
            const colors = [cube[pos.faces[0]][pos.indices[0]], cube[pos.faces[1]][pos.indices[1]], cube[pos.faces[2]][pos.indices[2]]];
            return { pos, colors };
        }

        // --- Stage 7: Orient Last Layer Corners ---
        function orientLastLayerCorners(steps, initialCubeState) {
            let tempState = JSON.parse(JSON.stringify(initialCubeState));
            const stageTitle = "Step 7: Orient Corners";
            const alg = "R' D' R D";
            const cornerPositions = ['DFR', 'DFL', 'DBL', 'DBR'];

            for (const posName of cornerPositions) {
                while (tempState.bottom[findCornerByPos(tempState, posName).pos.indices[0]] !== 'yellow') {
                    tempState = applyMovesToTempState(alg, steps, `${stageTitle}: Orient ${posName} Corner`, `Repeating algorithm until the corner's yellow sticker is on the bottom face.`, tempState);
                }
                if (posName !== 'DBR') {
                   tempState = applyMovesToTempState("D", steps, `${stageTitle}: Move to Next Corner`, `Bringing the next corner into the working position.`, tempState);
                }
            }

            const faceOrder = ['front', 'right', 'back', 'left'];
            const currentFrontColor = tempState.front[7];
            const targetFrontColor = solvedCubeState.front[4];
            const sideColors = faceOrder.map(f => solvedCubeState[f][4]);
            const currentIdx = sideColors.indexOf(currentFrontColor);
            const targetIdx = sideColors.indexOf(targetFrontColor);
            let diff = (targetIdx - currentIdx + 4) % 4;
            let dMoves = ['', 'D_prime', 'D D', 'D'][diff];
            if (dMoves) {
                tempState = applyMovesToTempState(dMoves, steps, "Final Alignment", "Aligning the last layer with the rest of the cube.", tempState);
            }
            return tempState;
        }

        // Checks if the current cube state matches the solved state
        function isSolved() {
            for (const face of FACES) {
                for (let i = 0; i < 9; i++) {
                    if (cubeState[face][i] !== solvedCubeState[face][i]) {
                        return false;
                    }
                }
            }
            return true;
        }
        
        // Returns a new state after applying a move, without mutating the original
        function getNextState(currentState, move) {
            const newState = JSON.parse(JSON.stringify(currentState));
            let tempRow, tempCol;
            switch (move) {
                case 'U':
                    newState.top = rotateFaceClockwise(newState.top);
                    tempRow = newState.front.slice(0, 3);
                    newState.front.splice(0, 3, ...newState.right.slice(0, 3));
                    newState.right.splice(0, 3, ...newState.back.slice(0, 3));
                    newState.back.splice(0, 3, ...newState.left.slice(0, 3));
                    newState.left.splice(0, 3, ...tempRow);
                    break;
                case 'U_prime':
                    newState.top = rotateFaceCounterClockwise(newState.top);
                    tempRow = newState.front.slice(0, 3);
                    newState.front.splice(0, 3, ...newState.left.slice(0, 3));
                    newState.left.splice(0, 3, ...newState.back.slice(0, 3));
                    newState.back.splice(0, 3, ...newState.right.slice(0, 3));
                    newState.right.splice(0, 3, ...tempRow);
                    break;
                case 'D':
                    newState.bottom = rotateFaceClockwise(newState.bottom);
                    tempRow = newState.front.slice(6, 9);
                    newState.front.splice(6, 3, ...newState.left.slice(6, 9));
                    newState.left.splice(6, 3, ...newState.back.slice(6, 9));
                    newState.back.splice(6, 3, ...newState.right.slice(6, 9));
                    newState.right.splice(6, 3, ...tempRow);
                    break;
                case 'D_prime':
                    newState.bottom = rotateFaceCounterClockwise(newState.bottom);
                    tempRow = newState.front.slice(6, 9);
                    newState.front.splice(6, 3, ...newState.right.slice(6, 9));
                    newState.right.splice(6, 3, ...newState.back.slice(6, 9));
                    newState.back.splice(6, 3, ...newState.left.slice(6, 9));
                    newState.left.splice(6, 3, ...tempRow);
                    break;
                case 'R':
                    newState.right = rotateFaceClockwise(newState.right);
                    tempCol = [newState.front[2], newState.front[5], newState.front[8]];
                    newState.front[2] = newState.bottom[2]; newState.front[5] = newState.bottom[5]; newState.front[8] = newState.bottom[8];
                    newState.bottom[2] = newState.back[6]; newState.bottom[5] = newState.back[3]; newState.bottom[8] = newState.back[0];
                    newState.back[6] = newState.top[2]; newState.back[3] = newState.top[5]; newState.back[0] = newState.top[8];
                    newState.top[2] = tempCol[0]; newState.top[5] = tempCol[1]; newState.top[8] = tempCol[2];
                    break;
                case 'R_prime':
                    newState.right = rotateFaceCounterClockwise(newState.right);
                    tempCol = [newState.front[2], newState.front[5], newState.front[8]];
                    newState.front[2] = newState.top[2]; newState.front[5] = newState.top[5]; newState.front[8] = newState.top[8];
                    newState.top[2] = newState.back[6]; newState.top[5] = newState.back[3]; newState.top[8] = newState.back[0];
                    newState.back[6] = newState.bottom[2]; newState.back[3] = newState.bottom[5]; newState.back[0] = newState.bottom[8];
                    newState.bottom[2] = tempCol[0]; newState.bottom[5] = tempCol[1]; newState.bottom[8] = tempCol[2];
                    break;
                case 'L':
                    newState.left = rotateFaceClockwise(newState.left);
                    tempCol = [newState.front[0], newState.front[3], newState.front[6]];
                    newState.front[0] = newState.top[0]; newState.front[3] = newState.top[3]; newState.front[6] = newState.top[6];
                    newState.top[0] = newState.back[8]; newState.top[3] = newState.back[5]; newState.top[6] = newState.back[2];
                    newState.back[8] = newState.bottom[0]; newState.back[5] = newState.bottom[3]; newState.back[2] = newState.bottom[6];
                    newState.bottom[0] = tempCol[0]; newState.bottom[3] = tempCol[1]; newState.bottom[6] = tempCol[2];
                    break;
                case 'L_prime':
                    newState.left = rotateFaceCounterClockwise(newState.left);
                    tempCol = [newState.front[0], newState.front[3], newState.front[6]];
                    newState.front[0] = newState.bottom[0]; newState.front[3] = newState.bottom[3]; newState.front[6] = newState.bottom[6];
                    newState.bottom[0] = newState.back[8]; newState.bottom[3] = newState.back[5]; newState.bottom[6] = newState.back[2];
                    newState.back[8] = newState.top[0]; newState.back[5] = newState.top[3]; newState.back[2] = newState.top[6];
                    newState.top[0] = tempCol[0]; newState.top[3] = tempCol[1]; newState.top[6] = tempCol[2];
                    break;
                case 'F':
                    newState.front = rotateFaceClockwise(newState.front);
                    tempCol = [newState.top[6], newState.top[7], newState.top[8]];
                    newState.top[6] = newState.left[8]; newState.top[7] = newState.left[5]; newState.top[8] = newState.left[2];
                    newState.left[8] = newState.bottom[2]; newState.left[5] = newState.bottom[1]; newState.left[2] = newState.bottom[0];
                    newState.bottom[2] = newState.right[0]; newState.bottom[1] = newState.right[3]; newState.bottom[0] = newState.right[6];
                    newState.right[0] = tempCol[0]; newState.right[3] = tempCol[1]; newState.right[6] = tempCol[2];
                    break;
                case 'F_prime':
                    newState.front = rotateFaceCounterClockwise(newState.front);
                    tempCol = [newState.top[6], newState.top[7], newState.top[8]];
                    newState.top[6] = newState.right[0]; newState.top[7] = newState.right[3]; newState.top[8] = newState.right[6];
                    newState.right[0] = newState.bottom[2]; newState.right[3] = newState.bottom[1]; newState.right[6] = newState.bottom[0];
                    newState.bottom[2] = newState.left[8]; newState.bottom[1] = newState.left[5]; newState.bottom[0] = newState.left[2];
                    newState.left[8] = tempCol[0]; newState.left[5] = tempCol[1]; newState.left[2] = tempCol[2];
                    break;
                case 'B':
                    newState.back = rotateFaceClockwise(newState.back);
                    tempCol = [newState.top[0], newState.top[1], newState.top[2]];
                    newState.top[0] = newState.right[2]; newState.top[1] = newState.right[5]; newState.top[2] = newState.right[8];
                    newState.right[2] = newState.bottom[8]; newState.right[5] = newState.bottom[7]; newState.right[8] = newState.bottom[6];
                    newState.bottom[8] = newState.left[6]; newState.bottom[7] = newState.left[3]; newState.bottom[6] = newState.left[0];
                    newState.left[6] = tempCol[0]; newState.left[3] = tempCol[1]; newState.left[0] = tempCol[2];
                    break;
                case 'B_prime':
                    newState.back = rotateFaceCounterClockwise(newState.back);
                    tempCol = [newState.top[0], newState.top[1], newState.top[2]];
                    newState.top[0] = newState.left[6]; newState.top[1] = newState.left[3]; newState.top[2] = newState.left[0];
                    newState.left[6] = newState.bottom[8]; newState.left[3] = newState.bottom[7]; newState.left[0] = newState.bottom[6];
                    newState.bottom[8] = newState.right[2]; newState.bottom[7] = newState.right[5]; newState.bottom[6] = newState.right[8];
                    newState.right[2] = tempCol[0]; newState.right[5] = tempCol[1]; newState.right[8] = tempCol[2];
                    break;
            }
            return newState;
        }

        // This is the core move engine, now it uses the pure function getNextState
        function applyMove(move) {
            cubeState = getNextState(cubeState, move);
        }

        function rotateFaceClockwise(face) {
            return [face[6], face[3], face[0], face[7], face[4], face[1], face[8], face[5], face[2]];
        }
        
        function rotateFaceCounterClockwise(face) {
            return [face[2], face[5], face[8], face[1], face[4], face[7], face[0], face[3], face[6]];
        }
        
        // --- Validation ---
        function validateCubeState() {
            const counts = {};
            for (const color of COLOR_NAMES) {
                counts[color] = 0;
            }
            
            for (const face in cubeState) {
                for (const color of cubeState[face]) {
                    counts[color] = (counts[color] || 0) + 1;
                }
            }
            
            for (const color in counts) {
                if (counts[color] !== 9) {
                    console.error(`Invalid number of ${color} stickers: ${counts[color]}`);
                    return false;
                }
            }
            
            return true;
        }

        // --- Utility Functions ---
        function showMessage(message, duration = 2000) {
            const messageBox = document.getElementById('messageBox');
            messageBox.textContent = message;
            messageBox.classList.add('show');
            setTimeout(() => {
                messageBox.classList.remove('show');
            }, duration);
        }

        window.onload = initializeUI;
    </script>
</body>
</html>
