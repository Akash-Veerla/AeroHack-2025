<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Rubik's Cube Solver</title>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a1a1a;
            color: #e0e0e0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
        }

        .main-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            max-width: 900px;
            width: 100%;
            background-color: #2c2c2c;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            text-align: center;
        }

        h1 {
            color: #ffffff;
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
        }

        p {
            font-size: 1rem;
            max-width: 600px;
            color: #b0b0b0;
            margin-bottom: 20px;
        }

        .cube-and-controls {
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
            justify-content: center;
            align-items: flex-start;
            gap: 40px;
            width: 100%;
        }
        
        .setup-section, .solve-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        .solve-section {
            display: none; /* Initially hidden */
        }
        
        .cube-container-2d {
            display: grid;
            grid-template-areas:
                ". top ."
                "left front right"
                ". bottom ."
                ". back .";
            gap: 2px;
            background-color: #333;
            padding: 5px;
            border-radius: 8px;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.5);
            transform: scale(0.8);
        }

        .face {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 2px;
            padding: 5px;
            background-color: #333;
            border: 2px solid #222;
        }

        .face.top    { grid-area: top; }
        .face.front  { grid-area: front; }
        .face.left   { grid-area: left; }
        .face.right  { grid-area: right; }
        .face.back   { grid-area: back; }
        .face.bottom { grid-area: bottom; }

        .sticker {
            width: 40px;
            height: 40px;
            border: 1px solid #1a1a1a;
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.2);
            transition: background-color 0.2s ease;
            cursor: pointer;
        }
        
        .sticker.center {
            cursor: default;
        }
        
        .color-palette {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
            padding: 10px;
            background-color: #333;
            border-radius: 8px;
        }

        .color-box {
            width: 30px;
            height: 30px;
            border-radius: 4px;
            border: 2px solid #555;
            cursor: pointer;
            transition: transform 0.2s;
        }
        
        .color-box.selected {
            border-color: #fff;
            box-shadow: 0 0 8px #fff;
            transform: scale(1.1);
        }

        .controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            width: 250px;
        }
        
        .controls-row {
            display: flex;
            gap: 10px;
            width: 100%;
        }

        .controls .btn {
            background-color: #444;
            color: #fff;
            border: none;
            padding: 12px 24px;
            font-size: 1rem;
            font-weight: 600;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
            text-transform: uppercase;
            letter-spacing: 1px;
            outline: none;
            width: 100%;
        }
        
        .controls-row .btn {
            width: 50%;
        }

        .controls .btn:hover {
            background-color: #555;
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.3);
        }

        .controls .btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .controls .btn:disabled {
            background-color: #333;
            color: #888;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .controls .btn.start-solve, .controls .btn.scramble-cube {
            background-color: #007BFF;
        }
        
        .controls .btn.start-solve:hover, .controls .btn.scramble-cube:hover {
            background-color: #0069d9;
        }

        .controls .btn.next-step {
            background-color: #4CAF50;
        }
        
        .controls .btn.next-step:hover {
            background-color: #45a049;
        }
        
        .controls .btn.secondary {
            background-color: #555;
        }
        
        .controls .btn.secondary:hover {
            background-color: #666;
        }

        .instruction-box {
            background-color: #333;
            color: #e0e0e0;
            border-radius: 8px;
            padding: 15px;
            text-align: left;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.5);
            width: 100%;
        }
        
        .instruction-box h3 {
            margin-top: 0;
            color: #ffffff;
            font-size: 1.2rem;
            border-bottom: 1px solid #555;
            padding-bottom: 10px;
            margin-bottom: 10px;
        }

        .instruction-box p {
            margin: 0 0 10px 0;
            text-align: left;
        }

        .instruction-box code {
            background-color: #444;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 0.9rem;
            color: #FFD700;
        }

        .message-box {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #333;
            color: #fff;
            padding: 15px 25px;
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.5s ease, visibility 0.5s ease;
        }

        .message-box.show {
            opacity: 1;
            visibility: visible;
        }
        
        @media (max-width: 768px) {
            .cube-and-controls {
                flex-direction: column;
                align-items: center;
            }
            .cube-container-2d {
                transform: scale(0.9);
            }
            .controls {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="main-container">
        <h1>Interactive Rubik's Cube Solver</h1>
        <p>Enter the colors of your scrambled cube or click 'Scramble Cube' to get a new one. Then, follow the step-by-step instructions to solve it!</p>

        <div class="cube-and-controls">
            <!-- Manual Input Section -->
            <div class="setup-section" id="setupSection">
                <div id="cubeContainer2D" class="cube-container-2d">
                    <!-- Faces will be dynamically added here -->
                </div>
                <div class="color-palette" id="colorPalette">
                    <!-- Colors will be dynamically added here -->
                </div>
                <div class="controls">
                    <button class="btn start-solve" onclick="startSolving()">Start Solving</button>
                    <button class="btn scramble-cube" onclick="scrambleCubeAndSolve()">Scramble Cube</button>
                    <button class="btn secondary" onclick="resetCube()">Reset</button>
                </div>
            </div>

            <!-- Solving Section -->
            <div class="solve-section" id="solveSection">
                <div id="solveCubeContainer2D" class="cube-container-2d">
                    <!-- Faces will be dynamically added here -->
                </div>
                <div class="controls">
                    <div class="instruction-box" id="instructionBox">
                        <h3>Instructions</h3>
                        <p id="simpleInstruction">Click "Next Step" to begin solving the cube.</p>
                        <p id="detailedInstruction"></p>
                        <p id="currentMove"></p>
                    </div>
                    <div class="controls-row">
                        <button class="btn" id="prevStepBtn" onclick="previousStep()">Previous Step</button>
                        <button class="btn next-step" id="nextStepBtn" onclick="nextStep()">Next Step</button>
                    </div>
                    <button class="btn secondary" onclick="showHome()">Home</button>
                </div>
            </div>
        </div>
    </div>

    <div id="messageBox" class="message-box"></div>

    <script>
        // Use a more accessible color palette
        const COLORS = {
            'white': '#ffffff',
            'yellow': '#ffd700',
            'red': '#ff0000',
            'orange': '#ff8c00',
            'blue': '#0000ff',
            'green': '#008000',
        };
        const COLOR_NAMES = ['white', 'yellow', 'red', 'orange', 'blue', 'green'];
        const FACES = ['front', 'back', 'top', 'bottom', 'left', 'right'];
        const ALL_MOVES = ['U', 'U_prime', 'D', 'D_prime', 'R', 'R_prime', 'L', 'L_prime', 'F', 'F_prime', 'B', 'B_prime'];
        const SCRAMBLE_LENGTH = 25;

        let cubeState = {};
        let solvedCubeState = {};
        let selectedColor = 'white';
        let setupSection, solveSection;
        let instructionBox, simpleInstruction, detailedInstruction, currentMoveDisplay;
        let solvingSteps = [];
        let currentStepIndex = -1;

        // --- UI Initialization ---
        function initializeUI() {
            setupSection = document.getElementById('setupSection');
            solveSection = document.getElementById('solveSection');
            instructionBox = document.getElementById('instructionBox');
            simpleInstruction = document.getElementById('simpleInstruction');
            detailedInstruction = document.getElementById('detailedInstruction');
            currentMoveDisplay = document.getElementById('currentMove');

            createCubeGrid('cubeContainer2D', true); // Create interactive cube for input
            createCubeGrid('solveCubeContainer2D', false); // Create passive cube for solving display
            createColorPalette();
            resetCubeState();
            updateCubeDisplay();
            updateNavigationButtons();
        }

        // Creates a 2D cube grid and attaches event listeners if interactive
        function createCubeGrid(containerId, isInteractive) {
            const container = document.getElementById(containerId);
            container.innerHTML = '';

            FACES.forEach(faceName => {
                const face = document.createElement('div');
                face.className = `face ${faceName}`;
                face.dataset.face = faceName;
                for (let i = 0; i < 9; i++) {
                    const sticker = document.createElement('div');
                    sticker.className = `sticker ${i === 4 ? 'center' : ''}`;
                    sticker.dataset.index = i;
                    if (isInteractive && i !== 4) {
                        sticker.addEventListener('click', handleStickerClick);
                    }
                    face.appendChild(sticker);
                }
                container.appendChild(face);
            });
        }

        // Creates the color palette for manual input
        function createColorPalette() {
            const palette = document.getElementById('colorPalette');
            palette.innerHTML = '';
            COLOR_NAMES.forEach(color => {
                const colorBox = document.createElement('div');
                colorBox.className = 'color-box';
                colorBox.style.backgroundColor = COLORS[color];
                colorBox.dataset.color = color;
                colorBox.addEventListener('click', handleColorPaletteClick);
                palette.appendChild(colorBox);
            });
            // Select the initial color
            document.querySelector(`[data-color="${selectedColor}"]`).classList.add('selected');
        }

        // Event handler for selecting a color
        function handleColorPaletteClick(event) {
            const oldSelected = document.querySelector('.color-box.selected');
            if (oldSelected) oldSelected.classList.remove('selected');
            selectedColor = event.target.dataset.color;
            event.target.classList.add('selected');
        }

        // Event handler for clicking a sticker to change its color
        function handleStickerClick(event) {
            const sticker = event.target;
            const face = sticker.parentElement.dataset.face;
            const index = sticker.dataset.index;
            cubeState[face][index] = selectedColor;
            updateCubeDisplay();
        }

        // Resets the cube to a solved state for fresh input
        function resetCubeState() {
            solvedCubeState = {
                'front': ['green', 'green', 'green', 'green', 'green', 'green', 'green', 'green', 'green'],
                'back': ['blue', 'blue', 'blue', 'blue', 'blue', 'blue', 'blue', 'blue', 'blue'],
                'top': ['white', 'white', 'white', 'white', 'white', 'white', 'white', 'white', 'white'],
                'bottom': ['yellow', 'yellow', 'yellow', 'yellow', 'yellow', 'yellow', 'yellow', 'yellow', 'yellow'],
                'left': ['orange', 'orange', 'orange', 'orange', 'orange', 'orange', 'orange', 'orange', 'orange'],
                'right': ['red', 'red', 'red', 'red', 'red', 'red', 'red', 'red', 'red']
            };
            cubeState = JSON.parse(JSON.stringify(solvedCubeState));
        }

        // Updates the visual display of the cube based on the cubeState array
        function updateCubeDisplay() {
            FACES.forEach(faceName => {
                const setupFaceElement = document.querySelector(`#cubeContainer2D .face.${faceName}`);
                const solveFaceElement = document.querySelector(`#solveCubeContainer2D .face.${faceName}`);
                if (setupFaceElement) {
                  const stickers = setupFaceElement.querySelectorAll('.sticker');
                  cubeState[faceName].forEach((color, index) => {
                      stickers[index].style.backgroundColor = COLORS[color];
                  });
                }
                if (solveFaceElement) {
                  const solveStickers = solveFaceElement.querySelectorAll('.sticker');
                  cubeState[faceName].forEach((color, index) => {
                      solveStickers[index].style.backgroundColor = COLORS[color];
                  });
                }
            });
        }

        // --- Core Application Flow ---
        function startSolving() {
            // Check if the cube is already solved
            if (isSolved()) {
                showMessage("The cube is already solved!", 3000);
                return;
            }

            // 1. Validate the cube state
            if (!validateCubeState()) {
                showMessage("Invalid cube state. Please ensure you have 9 stickers of each color.", 5000);
                return;
            }

            // 2. Generate the full solution
            solvingSteps = generateSolution();
            currentStepIndex = -1; // Start before the first step

            // 3. Switch to solve view
            setupSection.style.display = 'none';
            solveSection.style.display = 'flex';

            // 4. Start the solving process
            updateUIForStep();
        }

        function nextStep() {
            if (currentStepIndex < solvingSteps.length - 1) {
                currentStepIndex++;
                const step = solvingSteps[currentStepIndex];
                if (step.move) {
                    applyMove(step.move); // This now applies to the main cubeState
                }
                updateUIForStep();
            }
        }

        function previousStep() {
            if (currentStepIndex > 0) {
                const step = solvingSteps[currentStepIndex];
                if (step.move) {
                    const inverseMove = getInverseMove(step.move);
                    applyMove(inverseMove); // This now applies to the main cubeState
                }
                currentStepIndex--;
                updateUIForStep();
            }
        }

        function getInverseMove(move) {
            switch(move) {
                case 'U': return 'U_prime';
                case 'U_prime': return 'U';
                case 'D': return 'D_prime';
                case 'D_prime': return 'D';
                case 'R': return 'R_prime';
                case 'R_prime': return 'R';
                case 'L': return 'L_prime';
                case 'L_prime': return 'L';
                case 'F': return 'F_prime';
                case 'F_prime': return 'F';
                case 'B': return 'B_prime';
                case 'B_prime': return 'B';
                default: return null;
            }
        }

        function updateUIForStep() {
            const prevBtn = document.getElementById('prevStepBtn');
            const nextBtn = document.getElementById('nextStepBtn');

            // Disable/Enable buttons based on current step
            prevBtn.disabled = currentStepIndex <= -1;
            nextBtn.disabled = currentStepIndex >= solvingSteps.length - 1 || isSolved();

            if (currentStepIndex === -1) {
                // Initial state before solving starts
                simpleInstruction.textContent = "Click 'Next Step' to begin solving the cube.";
                detailedInstruction.textContent = "This will apply the first move of the solution.";
                currentMoveDisplay.innerHTML = "";
            } else {
                const step = solvingSteps[currentStepIndex];

                updateCubeDisplay();

                // Update instructions
                simpleInstruction.textContent = step.simpleText;
                detailedInstruction.textContent = step.detailedText;
                currentMoveDisplay.innerHTML = step.move ? `Move: <code>${step.move}</code>` : '';
            }

            if (isSolved()) {
                showMessage("The cube is now solved!", 5000);
                nextBtn.disabled = true;
            }
        }

        function showHome() {
            // Return to the setup screen
            setupSection.style.display = 'flex';
            solveSection.style.display = 'none';
            updateNavigationButtons();
            // Reset the cube to the solved state to prevent confusion
            resetCubeState();
            updateCubeDisplay();
        }

        function resetCube() {
            resetCubeState();
            updateCubeDisplay();
            showHome();
            showMessage("Cube state has been reset.", 2000);
        }

        function scrambleCubeAndSolve() {
            resetCubeState(); // Start from a solved state

            // Generate a random scramble of SCRAMBLE_LENGTH moves
            const tempCubeState = JSON.parse(JSON.stringify(cubeState));
            const scrambleMoves = [];
            for (let i = 0; i < SCRAMBLE_LENGTH; i++) {
                const randomMove = ALL_MOVES[Math.floor(Math.random() * ALL_MOVES.length)];
                scrambleMoves.push(randomMove);
                applyMove(randomMove);
            }

            updateCubeDisplay();
            startSolving();
        }

        function updateNavigationButtons() {
            const prevBtn = document.getElementById('prevStepBtn');
            const nextBtn = document.getElementById('nextStepBtn');
            if (prevBtn) prevBtn.disabled = true;
            if (nextBtn) nextBtn.disabled = false;
        }

        // --- Core Solving Algorithm Logic ---
        function generateSolution() {
            const tempState = JSON.parse(JSON.stringify(cubeState));
            let solutionSteps = [];

            // Each function will now take a state, modify it, and return the steps
            solutionSteps.push(...solveWhiteCross(tempState));
            solutionSteps.push(...solveWhiteCorners(tempState));
            solutionSteps.push(...solveMiddleLayer(tempState));
            solutionSteps.push(...solveYellowCross(tempState));
            solutionSteps.push(...permuteLastLayerEdges(tempState));
            solutionSteps.push(...permuteLastLayerCorners(tempState));
            solutionSteps.push(...orientLastLayerCorners(tempState));

            return solutionSteps;
        }

        function applyMoveToState(state, move) {
            const newState = JSON.parse(JSON.stringify(state));
            let tempRow, tempCol;

            switch (move) {
                case 'U':
                    newState.top = rotateFaceClockwise(newState.top);
                    tempRow = newState.front.slice(0, 3);
                    newState.front.splice(0, 3, ...newState.right.slice(0, 3));
                    newState.right.splice(0, 3, ...newState.back.slice(0, 3));
                    newState.back.splice(0, 3, ...newState.left.slice(0, 3));
                    newState.left.splice(0, 3, ...tempRow);
                    break;
                case 'U_prime':
                    newState.top = rotateFaceCounterClockwise(newState.top);
                    tempRow = newState.front.slice(0, 3);
                    newState.front.splice(0, 3, ...newState.left.slice(0, 3));
                    newState.left.splice(0, 3, ...newState.back.slice(0, 3));
                    newState.back.splice(0, 3, ...newState.right.slice(0, 3));
                    newState.right.splice(0, 3, ...tempRow);
                    break;
                case 'D':
                    newState.bottom = rotateFaceClockwise(newState.bottom);
                    tempRow = newState.front.slice(6, 9);
                    newState.front.splice(6, 3, ...newState.left.slice(6, 9));
                    newState.left.splice(6, 3, ...newState.back.slice(6, 9));
                    newState.back.splice(6, 3, ...newState.right.slice(6, 9));
                    newState.right.splice(6, 3, ...tempRow);
                    break;
                case 'D_prime':
                    newState.bottom = rotateFaceCounterClockwise(newState.bottom);
                    tempRow = newState.front.slice(6, 9);
                    newState.front.splice(6, 3, ...newState.right.slice(6, 9));
                    newState.right.splice(6, 3, ...newState.back.slice(6, 9));
                    newState.back.splice(6, 3, ...newState.left.slice(6, 9));
                    newState.left.splice(6, 3, ...tempRow);
                    break;
                case 'R':
                    newState.right = rotateFaceClockwise(newState.right);
                    tempCol = [newState.front[2], newState.front[5], newState.front[8]];
                    newState.front[2] = newState.bottom[2]; newState.front[5] = newState.bottom[5]; newState.front[8] = newState.bottom[8];
                    newState.bottom[2] = newState.back[6]; newState.bottom[5] = newState.back[3]; newState.bottom[8] = newState.back[0];
                    newState.back[6] = newState.top[2]; newState.back[3] = newState.top[5]; newState.back[0] = newState.top[8];
                    newState.top[2] = tempCol[0]; newState.top[5] = tempCol[1]; newState.top[8] = tempCol[2];
                    break;
                case 'R_prime':
                    newState.right = rotateFaceCounterClockwise(newState.right);
                    tempCol = [newState.front[2], newState.front[5], newState.front[8]];
                    newState.front[2] = newState.top[2]; newState.front[5] = newState.top[5]; newState.front[8] = newState.top[8];
                    newState.top[2] = newState.back[6]; newState.top[5] = newState.back[3]; newState.top[8] = newState.back[0];
                    newState.back[6] = newState.bottom[2]; newState.back[3] = newState.bottom[5]; newState.back[0] = newState.bottom[8];
                    newState.bottom[2] = tempCol[0]; newState.bottom[5] = tempCol[1]; newState.bottom[8] = tempCol[2];
                    break;
                case 'L':
                    newState.left = rotateFaceClockwise(newState.left);
                    tempCol = [newState.front[0], newState.front[3], newState.front[6]];
                    newState.front[0] = newState.top[0]; newState.front[3] = newState.top[3]; newState.front[6] = newState.top[6];
                    newState.top[0] = newState.back[8]; newState.top[3] = newState.back[5]; newState.top[6] = newState.back[2];
                    newState.back[8] = newState.bottom[0]; newState.back[5] = newState.bottom[3]; newState.back[2] = newState.bottom[6];
                    newState.bottom[0] = tempCol[0]; newState.bottom[3] = tempCol[1]; newState.bottom[6] = tempCol[2];
                    break;
                case 'L_prime':
                    newState.left = rotateFaceCounterClockwise(newState.left);
                    tempCol = [newState.front[0], newState.front[3], newState.front[6]];
                    newState.front[0] = newState.bottom[0]; newState.front[3] = newState.bottom[3]; newState.front[6] = newState.bottom[6];
                    newState.bottom[0] = newState.back[8]; newState.bottom[3] = newState.back[5]; newState.bottom[6] = newState.back[2];
                    newState.back[8] = newState.top[0]; newState.back[5] = newState.top[3]; newState.back[2] = newState.top[6];
                    newState.top[0] = tempCol[0]; newState.top[3] = tempCol[1]; newState.top[6] = tempCol[2];
                    break;
                case 'F':
                    newState.front = rotateFaceClockwise(newState.front);
                    tempRow = [newState.top[6], newState.top[7], newState.top[8]];
                    newState.top[6] = newState.left[8]; newState.top[7] = newState.left[5]; newState.top[8] = newState.left[2];
                    newState.left[8] = newState.bottom[2]; newState.left[5] = newState.bottom[1]; newState.left[2] = newState.bottom[0];
                    newState.bottom[2] = newState.right[0]; newState.bottom[1] = newState.right[3]; newState.bottom[0] = newState.right[6];
                    newState.right[0] = tempRow[0]; newState.right[3] = tempRow[1]; newState.right[6] = tempRow[2];
                    break;
                case 'F_prime':
                    newState.front = rotateFaceCounterClockwise(newState.front);
                    tempRow = [newState.top[6], newState.top[7], newState.top[8]];
                    newState.top[6] = newState.right[0]; newState.top[7] = newState.right[3]; newState.top[8] = newState.right[6];
                    newState.right[0] = newState.bottom[2]; newState.right[3] = newState.bottom[1]; newState.right[6] = newState.bottom[0];
                    newState.bottom[2] = newState.left[8]; newState.bottom[1] = newState.left[5]; newState.bottom[0] = newState.left[2];
                    newState.left[8] = tempRow[0]; newState.left[5] = tempRow[1]; newState.left[2] = tempRow[2];
                    break;
                case 'B':
                    newState.back = rotateFaceClockwise(newState.back);
                    tempRow = [newState.top[0], newState.top[1], newState.top[2]];
                    newState.top[0] = newState.right[2]; newState.top[1] = newState.right[5]; newState.top[2] = newState.right[8];
                    newState.right[2] = newState.bottom[8]; newState.right[5] = newState.bottom[7]; newState.right[8] = newState.bottom[6];
                    newState.bottom[8] = newState.left[6]; newState.bottom[7] = newState.left[3]; newState.bottom[6] = newState.left[0];
                    newState.left[6] = tempRow[0]; newState.left[3] = tempRow[1]; newState.left[0] = tempRow[2];
                    break;
                case 'B_prime':
                    newState.back = rotateFaceCounterClockwise(newState.back);
                    tempRow = [newState.top[0], newState.top[1], newState.top[2]];
                    newState.top[0] = newState.left[6]; newState.top[1] = newState.left[3]; newState.top[2] = newState.left[0];
                    newState.left[6] = newState.bottom[8]; newState.left[3] = newState.bottom[7]; newState.left[0] = newState.bottom[6];
                    newState.bottom[8] = newState.right[2]; newState.bottom[7] = newState.right[5]; newState.bottom[6] = newState.right[8];
                    newState.right[2] = tempRow[0]; newState.right[5] = tempRow[1]; newState.right[8] = tempRow[2];
                    break;
            }
            // Update the state that was passed in
            Object.assign(state, newState);
        }

        // Helper to apply a sequence of moves to a given cube state and return the steps
        function applyMoveSequence(state, moves, simpleText, detailedText) {
            const steps = [];
            for (const move of moves.split(' ')) {
                if (move) {
                    applyMoveToState(state, move);
                    steps.push({ simpleText, detailedText: `Perform move: ${move}`, move });
                }
            }
            return steps;
        }

        function getAdjacentFace(face, index) {
            const adjacencies = {
                top: { 0: { f: 'back', i: 1 }, 1: { f: 'back', i: 0 }, 2: { f: 'right', i: 1 }, 3: { f: 'back', i: 2 }, 5: { f: 'front', i: 0 }, 6: { f: 'left', i: 1 }, 7: { f: 'front', i: 1 }, 8: { f: 'front', i: 2 } },
                bottom: { 0: { f: 'front', i: 7 }, 1: { f: 'front', i: 8 }, 2: { f: 'right', i: 7 }, 3: { f: 'front', i: 6 }, 5: { f: 'back', i: 8 }, 6: { f: 'left', i: 7 }, 7: { f: 'back', i: 7 }, 8: { f: 'back', i: 6 } },
                front: { 0: { f: 'top', i: 7 }, 1: { f: 'top', i: 8 }, 2: { f: 'right', i: 0 }, 3: { f: 'top', i: 6 }, 5: { f: 'bottom', i: 2 }, 6: { f: 'left', i: 2 }, 7: { f: 'bottom', i: 1 }, 8: { f: 'bottom', i: 0 } },
                back: { 0: { f: 'top', i: 1 }, 1: { f: 'top', i: 0 }, 2: { f: 'left', i: 0 }, 3: { f: 'top', i: 2 }, 5: { f: 'bottom', i: 8 }, 6: { f: 'right', i: 2 }, 7: { f: 'bottom', i: 7 }, 8: { f: 'bottom', i: 6 } },
                left: { 0: { f: 'top', i: 3 }, 1: { f: 'top', i: 0 }, 2: { f: 'front', i: 0 }, 3: { f: 'top', i: 6 }, 5: { f: 'bottom', i: 0 }, 6: { f: 'back', i: 2 }, 7: { f: 'bottom', i: 3 }, 8: { f: 'bottom', i: 6 } },
                right: { 0: { f: 'top', i: 5 }, 1: { f: 'top', i: 2 }, 2: { f: 'back', i: 0 }, 3: { f: 'top', i: 8 }, 5: { f: 'bottom', i: 2 }, 6: { f: 'front', i: 2 }, 7: { f: 'bottom', i: 5 }, 8: { f: 'bottom', i: 8 } }
            };
            return { face: adjacencies[face][index].f, index: adjacencies[face][index].i };
        }

        function findEdge(state, color1, color2) {
            for (const face of FACES) {
                for (const index of [1, 3, 5, 7]) {
                    const stickerColor1 = state[face][index];
                    const adjacent = getAdjacentFace(face, index);
                    const stickerColor2 = state[adjacent.face][adjacent.index];
                    if ((stickerColor1 === color1 && stickerColor2 === color2) || (stickerColor1 === color2 && stickerColor2 === color1)) {
                        return { face1: face, index1: index, face2: adjacent.face, index2: adjacent.index };
                    }
                }
            }
            return null;
        }

        function findCorner(state, color1, color2, color3) {
            for (const face of FACES) {
                for (const index of [0, 2, 6, 8]) {
                    const stickerColor1 = state[face][index];
                    const adj1 = getAdjacentFace(face, index);
                    const adj2 = getAdjacentFace(face, (index + 2) % 8); // Simplified adjacency
                    const stickerColor2 = state[adj1.face][adj1.index];
                    const stickerColor3 = state[adj2.face][adj2.index];
                    const colorSet = new Set([stickerColor1, stickerColor2, stickerColor3]);
                    if (colorSet.has(color1) && colorSet.has(color2) && colorSet.has(color3)) {
                        return { face1: face, index1: index, face2: adj1.face, index2: adj1.index, face3: adj2.face, index3: adj2.index };
                    }
                }
            }
            return null;
        }

        function solveWhiteCross(state) {
            const steps = [];
            const edgesToSolve = [
                { colors: ['white', 'green'], target: 'front' },
                { colors: ['white', 'red'], target: 'right' },
                { colors: ['white', 'blue'], target: 'back' },
                { colors: ['white', 'orange'], target: 'left' }
            ];

            for (const edge of edgesToSolve) {
                let location = findEdge(state, edge.colors[0], edge.colors[1]);

                // This is a simplified logic, a full implementation would be more complex
                if (location.face1 === 'top') {
                    // Already on the top face, might need to be flipped or moved
                } else if (location.face1 === 'bottom') {
                    // Move to be under the target face, then move up
                    const moves = "F F";
                    steps.push(...applyMoveSequence(state, moves, `Move ${edge.colors[1]} edge up`, `Align and move the ${edge.colors[1]} edge.`));
                } else {
                    // It's in the middle layer, bring it down then up
                    const moves = "R U R'";
                    steps.push(...applyMoveSequence(state, moves, `Position ${edge.colors[1]} edge`, `Positioning the ${edge.colors[1]} edge.`));
                }
            }
            return steps;
        }

        function solveWhiteCorners(state) {
            const steps = [];
            const cornersToSolve = [
                { colors: ['white', 'green', 'orange'], pos: ['top', 'front', 'left'] },
                { colors: ['white', 'green', 'red'], pos: ['top', 'front', 'right'] },
                { colors: ['white', 'blue', 'orange'], pos: ['top', 'back', 'left'] },
                { colors: ['white', 'blue', 'red'], pos: ['top', 'back', 'right'] }
            ];

            for (const corner of cornersToSolve) {
                let location = findCorner(state, ...corner.colors);
                // Simplified logic
                if (location.face1 !== 'top') {
                    const moves = "R U R'";
                    steps.push(...applyMoveSequence(state, moves, `Position ${corner.colors[1]}/${corner.colors[2]} corner`, `Positioning the corner.`));
                }
            }
            return steps;
        }

        function solveMiddleLayer(state) {
            const steps = [];
            const edgesToSolve = [
                { colors: ['green', 'orange'], pos: ['front', 'left'] },
                { colors: ['green', 'red'], pos: ['front', 'right'] },
                { colors: ['blue', 'orange'], pos: ['back', 'left'] },
                { colors: ['blue', 'red'], pos: ['back', 'right'] }
            ];

            for (const edge of edgesToSolve) {
                let location = findEdge(state, edge.colors[0], edge.colors[1]);
                // Simplified logic
                const moves = "U R U' R' U' F' U F";
                steps.push(...applyMoveSequence(state, moves, `Insert ${edge.colors[0]}/${edge.colors[1]} edge`, `Inserting edge into middle layer.`));
            }
            return steps;
        }

        function solveYellowCross(state) {
            const steps = [];
            // Simplified logic: assumes one of the cases and applies the algorithm.
            const moves = "F R U R' U' F'";
            steps.push(...applyMoveSequence(state, moves, `Form yellow cross`, `Forming the yellow cross.`));
            return steps;
        }

        function permuteLastLayerEdges(state) {
            const steps = [];
            // Simplified logic
            const moves = "R U R' U R U2 R'";
            steps.push(...applyMoveSequence(state, moves, `Permute yellow edges`, `Permuting the yellow edges.`));
            return steps;
        }

        function permuteLastLayerCorners(state) {
            const steps = [];
            // Simplified logic
            const moves = "U R U' L' U R' U' L";
            steps.push(...applyMoveSequence(state, moves, `Permute yellow corners`, `Permuting the yellow corners.`));
            return steps;
        }

        function orientLastLayerCorners(state) {
            const steps = [];
            // Simplified logic
            const moves = "R' D' R D R' D' R D";
            steps.push(...applyMoveSequence(state, moves, `Orient yellow corners`, `Orienting the yellow corners.`));
            return steps;
        }

        // --- Global UI Functions ---

        // Checks if the current cube state matches the solved state
        function isSolved() {
            for (const face of FACES) {
                for (let i = 0; i < 9; i++) {
                    if (cubeState[face][i] !== solvedCubeState[face][i]) {
                        return false;
                    }
                }
            }
            return true;
        }

        // This is the core move engine for the main UI
        function applyMove(move) {
            applyMoveToState(cubeState, move);
        }

        function rotateFaceClockwise(face) {
            return [face[6], face[3], face[0], face[7], face[4], face[1], face[8], face[5], face[2]];
        }

        function rotateFaceCounterClockwise(face) {
            return [face[2], face[5], face[8], face[1], face[4], face[7], face[0], face[3], face[6]];
        }

        // --- Validation ---
        function validateCubeState() {
            const counts = {};
            for (const color of COLOR_NAMES) {
                counts[color] = 0;
            }

            for (const face in cubeState) {
                for (const color of cubeState[face]) {
                    counts[color] = (counts[color] || 0) + 1;
                }
            }

            for (const color in counts) {
                if (counts[color] !== 9) {
                    console.error(`Invalid number of ${color} stickers: ${counts[color]}`);
                    return false;
                }
            }

            return true;
        }

        // --- Utility Functions ---
        function showMessage(message, duration = 2000) {
            const messageBox = document.getElementById('messageBox');
            messageBox.textContent = message;
            messageBox.classList.add('show');
            setTimeout(() => {
                messageBox.classList.remove('show');
            }, duration);
        }

        window.onload = initializeUI;
    </script>
</body>
</html>
